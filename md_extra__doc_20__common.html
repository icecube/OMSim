<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="light-mode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OMSim: Framework functionality</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/svg+xml" href="logo.drawio.svg"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/icecube/OMSim" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logotest.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OMSim
   </div>
   <div id="projectbrief">Geant4 for IceCube optical module studies</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_extra__doc_20__common.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Framework functionality</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md2">Materials and User Data</a><ul><li class="level2"><a href="#autotoc_md3">Material Handling</a></li>
<li class="level2"><a href="#autotoc_md4">Optical Surfaces</a></li>
<li class="level2"><a href="#autotoc_md5">Special Material Types</a></li>
<li class="level2"><a href="#autotoc_md6">Geometry Data</a></li>
<li class="level2"><a href="#autotoc_md7">Adding New Data</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md9">Geometry construction</a></li>
<li class="level1"><a href="#autotoc_md11">Optical Modules and Harness Construction</a></li>
<li class="level1"><a href="#autotoc_md13">Making PMTs and OMs sensitive</a></li>
<li class="level1"><a href="#autotoc_md14">Storing hits and PMT response</a><ul><li class="level2"><a href="#autotoc_md15">PMTs Charge, transit time and detection probability</a></li>
<li class="level2"><a href="#autotoc_md16">Hit storage</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md18">Making other volumes sensitive to photons</a></li>
<li class="level1"><a href="#autotoc_md19">Non-terminating sensitive volumes for photon tracking</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a></p>
<p>This framework offers tools to simplify geometry construction and material definitions, as well as a detailed PMT response mechanism. This page provides a brief introduction to the main features.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md2"></a>
Materials and User Data</h1>
<p>User-defined material data are stored in JSON files under <code>/common/data</code> to avoid filling source code with numbers. The <code><a class="el" href="class_o_m_sim_input_data.html" title="Manages the input data, including parsing and storing material properties.">OMSimInputData</a></code> class (see <code><a class="el" href="_o_m_sim_input_data_8hh.html" title="Definition of ParameterTable and OMSimInputData.">OMSimInputData.hh</a></code>) is responsible for processing these files and loading the material properties into the Geant4 framework. It uses the <code><a class="el" href="class_o_m_sim_material_handler.html" title="Handles the creation and processing of materials from json files.">OMSimMaterialHandler</a></code> class to handle the specifics of material creation and property setting.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Material Handling</h2>
<p>The <code><a class="el" href="class_o_m_sim_material_handler.html" title="Handles the creation and processing of materials from json files.">OMSimMaterialHandler</a></code> class is the core component for creating and modifying materials. It provides several key methods:</p>
<ul>
<li><code><a class="el" href="class_o_m_sim_material_handler.html#a719ebf626a19a6e8ff9a0b9e2a262c21" title="Process the material defined in the input file.">OMSimMaterialHandler::processMaterial</a></code>: Creates a new material or modifies an existing one based on the data in the input file.</li>
<li><code><a class="el" href="class_o_m_sim_material_handler.html#a1cf8cf3badeaa28c33d4b96973239c71" title="Process and return an optical surface defined in the input file.">OMSimMaterialHandler::processSurface</a></code>: Processes and returns an optical surface defined in the input file.</li>
<li><code><a class="el" href="class_o_m_sim_material_handler.html#a2e87189ae05d3d960df85957c799ebf9" title="Process extra properties for an existing material.">OMSimMaterialHandler::processExtraProperties</a></code>: Adds additional properties to an existing material.</li>
<li><code><a class="el" href="class_o_m_sim_material_handler.html#ad337c539e395d32e708d18a4f5e48264" title="Process special material types using a provided function.">OMSimMaterialHandler::processSpecial</a></code>: Handles special material types like IceCube ice or scintillators that require custom processing.</li>
</ul>
<p>Materials created via this class can be retrieved using Geant4's conventional method <code>G4Material::GetMaterial</code>. The <code><a class="el" href="class_o_m_sim_input_data.html" title="Manages the input data, including parsing and storing material properties.">OMSimInputData</a></code> class also provides a wrapper method <code><a class="el" href="class_o_m_sim_input_data.html#a12e64f3ec83f33c173da0cd5954dd5b2" title="Retrieves a G4Material based on the given name.">OMSimInputData::getMaterial</a></code> to handle default parameters and special "argument materials".</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Optical Surfaces</h2>
<p>For optical surfaces, <code><a class="el" href="class_o_m_sim_input_data.html" title="Manages the input data, including parsing and storing material properties.">OMSimInputData</a></code> provides the method <code><a class="el" href="class_o_m_sim_input_data.html#aca56b05e268bbb47761dbcc8e487c283">OMSimInputData::getOpticalSurface</a></code>, which doesn't exist in Geant4 by default.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Special Material Types</h2>
<p>Different materials may require different types of properties and processing. The <code><a class="el" href="class_o_m_sim_material_handler.html" title="Handles the creation and processing of materials from json files.">OMSimMaterialHandler</a></code> class can handle various material types, including:</p>
<ul>
<li>Standard materials with refractive index and absorption properties</li>
<li>IceCube ice, where the optical properties are calculated by the selected depth (an arg variable)</li>
<li>Scintillator materials with complex decay time and yield properties</li>
</ul>
<p>Special processors for these materials are implemented in separate namespaces (e.g., <code><a class="el" href="namespace_ice_processor.html" title="Namespace containing functions for processing IceCube ice properties from file.">IceProcessor</a></code>, <code><a class="el" href="namespace_scintillation_processor.html" title="Namespace containing functions for processing files with scintillation properties.">ScintillationProcessor</a></code>) and can be passed to the <code><a class="el" href="class_o_m_sim_material_handler.html#ad337c539e395d32e708d18a4f5e48264" title="Process special material types using a provided function.">OMSimMaterialHandler::processSpecial</a></code> method.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Geometry Data</h2>
<p>PMT construction data is also stored in JSON files (<code>/common/data/PMTs</code>). This data is loaded into a "tree" (essentially a dictionary containing the JSON file's keys and values) in <code><a class="el" href="class_parameter_table.html#ae5dba23c394122524bab7cb8f61a2fe4" title="A table mapping keys to property trees.">OMSimInputData::m_table</a></code>. This approach allows for flexible PMT construction without defining a unique class for each PMT type.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Adding New Data</h2>
<p>To add new material data:</p>
<ol type="1">
<li>Create a new JSON file in the appropriate directory under <code>/common/data</code>.</li>
<li>If the material requires special processing, you may need to create a new processor function or namespace.</li>
<li>Update <code><a class="el" href="class_o_m_sim_input_data.html#a85c2bfa74bb3ac64f0e5f628d81bf4be" title="Processes a data file based on its name prefix.">OMSimInputData::processFile</a></code> to handle the new file type if necessary.</li>
</ol>
<p>For simpler tasks, you can use the static method <code><a class="el" href="namespace_tools.html#aefa5ecd8f1fb3d69a65d517494e99669" title="Reads numerical data from a file and returns it as a 2D vector. Similar to numpy.loadtxt.">Tools::loadtxt</a></code> provided by the <a href="md_extra_doc_2_technicalities.html#autotoc_md20"><code>Tools</code> namespace</a>.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md9"></a>
Geometry construction</h1>
<p>Each optical module and harness is defined in its respective class, located in the <code>/common/geometry_construction/</code> folder. These inherit from the virtual base class <code><a class="el" href="class_o_m_sim_optical_module.html" title="Base class for OMs works as interface.">OMSimOpticalModule</a></code>.</p>
<p>This inheritance ensures the definition of functions to retrieve the pressure vessel's weight (necessary for radioactive decay studies) and the count of PMTs inside the module. The <code><a class="el" href="class_o_m_sim_optical_module.html" title="Base class for OMs works as interface.">OMSimOpticalModule</a></code> interface inherits from <code><a class="el" href="class_o_m_sim_detector_component.html" title="Abstract base class used for constructing detector components.">OMSimDetectorComponent</a></code>, a general helper class simplifying construction. Most <a class="el" href="class_o_m_sim.html" title="Controls the main simulation process.">OMSim</a> geometries inherit from this class, as illustrated in the dependency diagram below:</p>
<p><img src="class_o_m_sim_detector_component__inherit__graph.svg" alt="Inheritance diagram" style="pointer-events: none;" class="inline"/></p>
<p>The <code><a class="el" href="class_o_m_sim_p_m_t_construction.html">OMSimPMTConstruction</a></code> class constructs PMTs. There are two PMT construction approaches. The first is simple, with a solid photocathode where all entering photons are recorded. This mode can be activated using the argument <code>--simple_PMT</code>. The second, default, approach simulates the photocathode as a thin layer, also representing the internal components accounting for internal reflections. For more information, refer to Chapter 9 of <a href="https://zenodo.org/record/8121321">this thesis</a>.</p>
<p>In the complex PMT model, the photocathodes are not real volumes, but are defined as a boundary condition between the glass and internal vacuum. The original <code><a class="el" href="class_g4_op_boundary_process.html">G4OpBoundaryProcess</a></code> of Geant4 was modified in <code>OMSimOpBoundaryProcess.cc</code> in order to simulate the optical propierties of thin layers (see <a href="https://www.uni-muenster.de/imperia/md/content/physik_kp/agkappes/abschlussarbeiten/masterarbeiten/ma_krybus.pdf">Nicolai Krybus's thesis</a>).</p>
<p>The construction of different PMT models (e.g. the 3'' or 10'' PMTs) is quite similar. However, the frontal window shape varies among models, leading to diverse combinations of ellipsoids and spheres.</p>
<div style="width: 100%; text-align: center;"> <img src="simulation_vs_sketch_old.png" alt="Cross section of simple mDOM PMT model" width="280" height="320" class="inline"/> <div style="width: 80%; margin: auto;"> <br  />
 Figure 1: <em>Cross section of simple <a class="el" href="classm_d_o_m.html">mDOM</a> PMT model. Image from <a href="https://zenodo.org/record/8121321">M. Unland's thesis</a>.</em> </div></div><div style="width: 100%; text-align: center;"></div> <div style="width: 100%; text-align: center;"> <img src="simulation_dynodes_screenshot.png" alt="Side view of complex mDOM PMT model" width="400" height="328" class="inline"/> <div style="width: 80%; margin: auto;"> <br  />
 Figure 2: <em>Side view of complex <a class="el" href="classm_d_o_m.html">mDOM</a> PMT model. Image from <a href="https://zenodo.org/record/8121321">M. Unland's thesis</a>.</em> </div> </div><hr  />
<h1><a class="anchor" id="autotoc_md11"></a>
Optical Modules and Harness Construction</h1>
<p>For most optical modules, complex geometries like holding structures and harnesses are constructed from CAD files (<code>.obj</code> - see <a href="md_extra__doc_22__technicalities.html#autotoc_md43">CAD geometries</a>). Using CAD files might increase the geometry construction time. However, once the geometry is initialized, the rest of the simulation proceeds as usual. Therefore, users are advised to structure their simulations to minimize repeated geometry construction. The <a class="el" href="classm_d_o_m.html">mDOM</a> is however fully constructed natively in Geant4. For details on the harness implementation, refer to <a href="https://www.uni-muenster.de/imperia/md/content/physik_kp/agkappes/abschlussarbeiten/bachelorarbeiten/ba_moritz_schlechtriem.pdf">this Bachelor thesis</a>.</p>
<p>The following geometries cannot be visualized:</p>
<ul>
<li>PMT HA-coating</li>
<li>DOM/pDOM complex PMT (use <code>--simple_PMT</code> instead)</li>
<li><a class="el" href="classm_d_o_m.html">mDOM</a> support structure</li>
</ul>
<p>Below is an overview of the available geometries:</p>
<div style="width: 100%; text-align: center;"> <img src="optical_modules.png" alt="Cross section of simple mDOM PMT model" width="400" height="320" class="inline"/> <div style="width: 80%; margin: auto;"> <br  />
 Figure 1: <em>Real-world optical modules (top) compared to their respective visualization in <a class="el" href="class_o_m_sim.html" title="Controls the main simulation process.">OMSim</a> (bottom).</em> </div> </div><p>To recreate the geometries, use the following commands:</p>
<div class="fragment"><div class="line">./OMSim_effective_area --detector_type 2 --place_harness -v</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">./OMSim_effective_area --detector_type 3 --place_harness -v --simple_PMT</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md13"></a>
Making PMTs and OMs sensitive</h1>
<p>For photon detection in both simple and complex geometries, the photons must be absorbed within the photocathode. The photocathodes are made sensitive through the <a class="el" href="class_o_m_sim_sensitive_detector.html" title="Represents a sensitive detector.">OMSimSensitiveDetector</a> class, following Geant4's G4VSensitiveDetector pattern. This configuration is achieved by invoking <code>OMSimOpticalModule::configureSensitiveVolume</code> (or <code>OMSimPMTConstruction::configureSensitiveVolume</code> when simulating a single PMT).</p>
<p>It is essential to invoke this method in the detector construction, as it needs the instance of <code><a class="el" href="class_o_m_sim_detector_construction.html" title="Class for detector construction in the effective area simulation.">OMSimDetectorConstruction</a></code> to call <code>G4VUserDetectorConstruction::SetSensitiveDetector</code> for successful operation in Geant4 (refer to <code>OMSimDetectorConstruction::registerSensitiveDetector</code>).</p>
<blockquote class="doxtable">
<p>&zwj;<b>Important</b>: Creating a new instance for each module to ensure that hits are correctly associated with their respective modules and prevents cross-talk between detectors. </p>
</blockquote>
<p>Here's an example of how to properly create and configure sensitive detectors for multiple optical modules:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numberOfModules; ++i) {</div>
<div class="line">    <a class="code hl_class" href="classm_d_o_m.html">mDOM</a>* <span class="keyword">module</span> = new mDOM(false);</div>
<div class="line">    G4String nameExtension = <span class="stringliteral">&quot;_&quot;</span> + std::to_string(i);</div>
<div class="line">    <span class="keyword">module</span>-&gt;placeIt(G4ThreeVector(0, 0, i*3*m), G4RotationMatrix(), m_worldLogical, nameExtension); <span class="comment">//you have to have unique names</span></div>
<div class="line">    <span class="keyword">module</span>-&gt;configureSensitiveVolume(this);</div>
<div class="line">}</div>
<div class="ttc" id="aclassm_d_o_m_html"><div class="ttname"><a href="classm_d_o_m.html">mDOM</a></div><div class="ttdef"><b>Definition</b> OMSimMDOM.hh:13</div></div>
</div><!-- fragment --><p>Every step of a particle through the photocathode triggers the <code><a class="el" href="class_o_m_sim_sensitive_detector.html#a2d12fa5869b30eee35a85793522e98f4" title="Processes hits for optical photons in the detector.">OMSimSensitiveDetector::ProcessHits</a></code> method. It verifies if the particle is a photon and whether it was absorbed. For a deeper understanding of Geant4's philosophy concerning G4VSensitiveDetector, consult the <a href="https://geant4-userdoc.web.cern.ch/UsersGuides/ForApplicationDeveloper/html/Detector/hit.html?highlight=g4vsensitivedetector#g4vsensitivedetector">Geant4 guide for application developers</a>.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Storing hits and PMT response</h1>
<h2><a class="anchor" id="autotoc_md15"></a>
PMTs Charge, transit time and detection probability</h2>
<p>In <code>OMSimPMTConstruction::configureSensitiveVolume</code>, PMTs are associated with an instance of <code><a class="el" href="class_o_m_sim_p_m_t_response.html" title="Class to simulate PMT response.">OMSimPMTResponse</a></code>, contingent on the PMT under simulation. This class offers a precise PMT simulation by sampling from real measurements, obtaining the relative transit time, charge (in PE), and detection probability (using the measured scans from <a href="https://zenodo.org/record/8121321">this thesis</a>). For details, refer to Section 9.3.4 of the linked thesis.</p>
<p>This sampling is performed for every absorbed photon in <code><a class="el" href="class_o_m_sim_sensitive_detector.html#a2d12fa5869b30eee35a85793522e98f4" title="Processes hits for optical photons in the detector.">OMSimSensitiveDetector::ProcessHits</a></code> invoking <code><a class="el" href="class_o_m_sim_p_m_t_response.html#a55aabd8f8fd9be58eca3ba0753974d08" title="Process a hit on the photocathode into a PMT pulse.">OMSimPMTResponse::processPhotocathodeHit</a></code>. The position of the photon on the photocathode is retrieved, the 2D-histograms of the gain, SPE resolution, transit time and TTS are interpolated for that position and the charge / transit time of the photon is sampled from a Gaussian using the interpolated values as mean (in case of gain / transit time) and standard deviation (in case of SPE resolution / TTS).</p>
<div style="width: 100%; text-align: center;"> <img src="PW_beam_geant4_TT.png" alt="PMT response compared to measurement" width="256" height="440" class="inline"/> <div style="width: 80%; margin: auto;"> <br  />
 Figure 3: <em>PMT response compared to measurement for different light sources. Image from <a href="https://zenodo.org/record/8121321">M. Unland's thesis</a>.</em> </div> </div><p>If you use the complex PMT model, you will obtain detection probability weights, which are the product of quantum efficiency (QE)—which varies with photon wavelength—and collection efficiency weight (which depends on absorption position). These weights are calibrated to match measurements. For more technical details, see the section <a href="md_extra__doc_22__technicalities.html#autotoc_md37">Matching PMT Efficiency to Measurements</a>.</p>
<p>In contrast, with the simple PMT model, the detection probability weight is solely the QE. Since the measured QE is reduced due to absorption in the PMT glass, the simulated tube glass will have no defined absorption length.</p>
<div style="width: 100%; text-align: center;"> <img src="QE_meas_VS_simulation.png" alt="QE of simulation compared to measurements" width="360" height="308" class="inline"/> <div style="width: 80%; margin: auto;"> <br  />
 Figure 4: <em>QE of simulation with the absorption length currently used compared to measurements. Image from <a href="https://zenodo.org/record/8121321">this thesis</a>.</em> </div> </div><div style="width: 100%; text-align: center;"> <img src="rel_de.png" alt="DE of simulation compared to measurements" width="600" height="250" class="inline"/> <div style="width: 80%; margin: auto;"> <br  />
 Figure 5: <em>Detection efficiency simulation (left) compared to measurement (right) using the calculated collection efficiency weights. Image from <a href="https://zenodo.org/record/8121321">M. Unland's thesis</a>.</em> </div> </div><h2><a class="anchor" id="autotoc_md16"></a>
Hit storage</h2>
<p>The absorbed photon data is managed by the <code><a class="el" href="class_o_m_sim_hit_manager.html" title="Manages detected photon information.">OMSimHitManager</a></code> global instance. It maintains a vector of hit information (<code><a class="el" href="struct_hit_stats.html" title="A structure of vectors to store information about detected photons.">HitStats</a></code> struct) for each sensitive detector. To analyze and export this data, use the <code><a class="el" href="class_o_m_sim_hit_manager.html#a45a63dbb6cdb3815db3cfde00ae36f70" title="Retrieves the HitStats structure for the specified module of single thread.">OMSimHitManager::getSingleThreadHitsOfModule</a></code> method to retrieve data for the current thread, or <code><a class="el" href="class_o_m_sim_hit_manager.html#ae10481ea62eca89b774ced9e01b991ab" title="Retrieves the HitStats structure for the specified module, should be called after data between thread...">OMSimHitManager::getMergedHitsOfModule</a></code> to obtain merged data from all threads. Note that <code><a class="el" href="class_o_m_sim_hit_manager.html#ae10481ea62eca89b774ced9e01b991ab" title="Retrieves the HitStats structure for the specified module, should be called after data between thread...">OMSimHitManager::getMergedHitsOfModule</a></code> works only if <code>OMSimHitManager::mergeThreadData</code> has been called (happens at the end of the run when <code>OMSimRunActio::EndOfRunAction</code> is called). For analysis or storage at the end of an event, handle each thread separately as events end asynchronously. For practical examples, refer to the methods in <code>OMSimEffectiveAreaAnalysis</code> and <code>OMSimSNAnalysis::writeDataFile</code>.</p>
<p>An additional feature allows for the direct application of a QE cut. This ensures that only absorbed photons passing the QE test are retained in <code><a class="el" href="class_o_m_sim_hit_manager.html" title="Manages detected photon information.">OMSimHitManager</a></code>. To enable this feature, provide the "efficiency_cut" argument via the command line. In this case <code><a class="el" href="class_o_m_sim_sensitive_detector.html#a2d12fa5869b30eee35a85793522e98f4" title="Processes hits for optical photons in the detector.">OMSimSensitiveDetector::ProcessHits</a></code> will call <code><a class="el" href="class_o_m_sim_sensitive_detector.html#a8e4a324ae342e9e91ddc33fcc0be8789" title="Monte carlo if the photon was detected based on the detection probability.">OMSimSensitiveDetector::isPhotonDetected</a></code> and break early if it returns false, without storing the photon information. In most scenarios, it's not recommended to use &ndash;efficiency_cut since it reduces your statistics. It's generally better to perform post-analysis using the saved <code><a class="el" href="struct_o_m_sim_p_m_t_response_1_1_p_m_t_pulse.html#a87f21652e10a0bc82870ded9697b57f2" title="Probability of photon being detected.">OMSimPMTResponse::PMTPulse::detectionProbability</a></code> for each absorbed photon. In case that efficiency_cut is active and the photon is stored, its <code><a class="el" href="struct_o_m_sim_p_m_t_response_1_1_p_m_t_pulse.html#a87f21652e10a0bc82870ded9697b57f2" title="Probability of photon being detected.">OMSimPMTResponse::PMTPulse::detectionProbability</a></code> will change to 1, since it was detected.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md18"></a>
Making other volumes sensitive to photons</h1>
<p>For some studies, you might want a volume to detect photons, without this necessarily being a PMT. For such cases, the framework has a provision in place: use the <code><a class="el" href="class_o_m_sim_sensitive_detector.html" title="Represents a sensitive detector.">OMSimSensitiveDetector</a></code> and pass <code>DetectorType::GeneralPhotonDetector</code> as its constructor argument.</p>
<p>In this case, the <code><a class="el" href="class_o_m_sim_sensitive_detector.html#a2d12fa5869b30eee35a85793522e98f4" title="Processes hits for optical photons in the detector.">OMSimSensitiveDetector::ProcessHits</a></code> will use an instance <code>NoResponse</code> as PMT response, which is just a dummy placeholder. <br  />
</p>
<p>Remember to inform the <code><a class="el" href="class_o_m_sim_hit_manager.html" title="Manages detected photon information.">OMSimHitManager</a></code> that this detector is equivalent to "a single PMT", ensuring internal vector sizes adjust accordingly.</p>
<p>This approach ensures a smooth integration of the photosensitive volume within the current system. Below is an example illustrating how this can be incorporated within the detector construction:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;OMSimSensitiveDetector.hh&quot;</span></div>
<div class="line"><span class="comment">//... Assume the logical volume of your detector has been defined and is referred to as &quot;lDetectorLV&quot;</span></div>
<div class="line"><a class="code hl_class" href="class_o_m_sim_sensitive_detector.html">OMSimSensitiveDetector</a>* sensitiveDetector = <span class="keyword">new</span> <a class="code hl_class" href="class_o_m_sim_sensitive_detector.html">OMSimSensitiveDetector</a>(<span class="stringliteral">&quot;myDetector&quot;</span>, DetectorType::VolumePhotonDetector); </div>
<div class="line"><a class="code hl_class" href="class_o_m_sim_hit_manager.html">OMSimHitManager</a> &amp;hitManager =  <a class="code hl_function" href="class_o_m_sim_hit_manager.html#aaa3e7a28d658d8e2e6db704b910cc35c">OMSimHitManager::getInstance</a>();</div>
<div class="line">hitManager.<a class="code hl_function" href="class_o_m_sim_hit_manager.html#ab4a1060283a53660e52626d08a77ebc8">setNumberOfPMTs</a>(1, hitManager.getNextDetectorIndex());</div>
<div class="line">registerSensitiveDetector(lDetectorLV, sensitiveDetector);</div>
<div class="ttc" id="aclass_o_m_sim_hit_manager_html"><div class="ttname"><a href="class_o_m_sim_hit_manager.html">OMSimHitManager</a></div><div class="ttdoc">Manages detected photon information.</div><div class="ttdef"><b>Definition</b> OMSimHitManager.hh:56</div></div>
<div class="ttc" id="aclass_o_m_sim_hit_manager_html_aaa3e7a28d658d8e2e6db704b910cc35c"><div class="ttname"><a href="class_o_m_sim_hit_manager.html#aaa3e7a28d658d8e2e6db704b910cc35c">OMSimHitManager::getInstance</a></div><div class="ttdeci">static OMSimHitManager &amp; getInstance()</div><div class="ttdef"><b>Definition</b> OMSimHitManager.cc:44</div></div>
<div class="ttc" id="aclass_o_m_sim_hit_manager_html_ab4a1060283a53660e52626d08a77ebc8"><div class="ttname"><a href="class_o_m_sim_hit_manager.html#ab4a1060283a53660e52626d08a77ebc8">OMSimHitManager::setNumberOfPMTs</a></div><div class="ttdeci">void setNumberOfPMTs(int pNumberOfPMTs, int pModuleIndex=0)</div><div class="ttdoc">Stores the number of PMTs in a module for correct data handling.</div><div class="ttdef"><b>Definition</b> OMSimHitManager.cc:148</div></div>
<div class="ttc" id="aclass_o_m_sim_sensitive_detector_html"><div class="ttname"><a href="class_o_m_sim_sensitive_detector.html">OMSimSensitiveDetector</a></div><div class="ttdoc">Represents a sensitive detector.</div><div class="ttdef"><b>Definition</b> OMSimSensitiveDetector.hh:53</div></div>
</div><!-- fragment --><p>In this case, <code><a class="el" href="class_o_m_sim_sensitive_detector.html#a2d12fa5869b30eee35a85793522e98f4" title="Processes hits for optical photons in the detector.">OMSimSensitiveDetector::ProcessHits</a></code> will store all absorbed photons. The number of photons absorbed will depend on the absorption length of the material connected to the logical volume. If you want it to be 100% efficient, use the material <code>RiAbs_Absorber</code>.</p>
<p>If there's a need to make a volume sensitive to particles other than photons, add a new entry to the <code>DetectorType</code> enum (in <code><a class="el" href="_o_m_sim_sensitive_detector_8hh_source.html">OMSimSensitiveDetector.hh</a></code>) and incorporate a new method that handles this scenario in <code><a class="el" href="class_o_m_sim_sensitive_detector.html#a2d12fa5869b30eee35a85793522e98f4" title="Processes hits for optical photons in the detector.">OMSimSensitiveDetector::ProcessHits</a></code>. You might also track these particles in <code><a class="el" href="class_o_m_sim_tracking_action.html">OMSimTrackingAction</a></code> or <code><a class="el" href="class_o_m_sim_stepping_action.html">OMSimSteppingAction</a></code>, but using a class derived from <code>G4VSensitiveDetector</code> aligns with the philosophy of Geant4.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Non-terminating sensitive volumes for photon tracking</h1>
<p>If you want to inspect the properties of photons at a given location in your simulation without terminating them, you can use the <code>BoundaryShellDetector</code>. &gt;<b>Important</b>: This detector captures information when a photon leaves the corresponding logical volume.</p>
<p>Example from Figure 1:</p>
<div class="fragment"><div class="line">OMSimHitManager &amp;hitManager =  OMSimHitManager::getInstance();</div>
<div class="line">    </div>
<div class="line">// Create large sphere</div>
<div class="line"> </div>
<div class="line">G4Orb* lSolidSphere1 = new G4Orb(&quot;random_sphere_1&quot;, 0.24 * m);</div>
<div class="line">G4LogicalVolume* llogicSphere1 = new G4LogicalVolume(lSolidSphere1, m_data-&gt;getMaterial(&quot;argWorld&quot;), &quot;LogicSphericalShell1&quot;);</div>
<div class="line"> </div>
<div class="line">// Create smaller sphere contained by the large one</div>
<div class="line"> </div>
<div class="line">G4Orb* lSolidSphere2 = new G4Orb(&quot;random_sphere&quot;, 0.23 * m);</div>
<div class="line">G4LogicalVolume* llogicSphere2 = new G4LogicalVolume(lSolidSphere2, m_data-&gt;getMaterial(&quot;argWorld&quot;), &quot;LogicSphericalShell&quot;);</div>
<div class="line"> </div>
<div class="line">// Optionally set visualization attributes</div>
<div class="line">G4VisAttributes* visAttr = new G4VisAttributes(G4Colour(0.0, 1.0, 0.0, 0.2)); // green color</div>
<div class="line">llogicSphere1-&gt;SetVisAttributes(visAttr);</div>
<div class="line">G4VisAttributes* visAttr2 = new G4VisAttributes(G4Colour(0.0, 1.0, 0.0, 0.0)); // green color</div>
<div class="line">llogicSphere2-&gt;SetVisAttributes(visAttr2);</div>
<div class="line"> </div>
<div class="line">// Set sensitive detector</div>
<div class="line">OMSimSensitiveDetector* SpheresensitiveDetector = new OMSimSensitiveDetector(&quot;myDetector&quot;, DetectorType::BoundaryShellDetector);</div>
<div class="line">hitManager.setNumberOfPMTs(1, hitManager.getNextDetectorIndex());</div>
<div class="line">registerSensitiveDetector(llogicSphere1, SpheresensitiveDetector);</div>
</div><!-- fragment --><p> With this configuration, photon information will be recorded at the exit of the sphere with a radius of 24 cm, either because the photon entered the 23 cm-radius sphere or because it left the volume without ever touching it. </p><div style="width: 100%; text-align: center;"> <img src="shell_detector.png" alt="Cross section of simple mDOM PMT model" width="320" height="320" class="inline"/> <div style="width: 80%; margin: auto;"> <br  />
 Figure 1: <em>Usage of BoundaryShell detector.</em> </div></div><div style="width: 100%; text-align: center;"><hr  />
 </div></div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jun 10 2025 15:42:40 for OMSim by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
