\chapter{Technicalities for Developers}
\hypertarget{md_extra__doc_22__technicalities}{}\label{md_extra__doc_22__technicalities}\index{Technicalities for Developers@{Technicalities for Developers}}
\label{md_extra__doc_22__technicalities_autotoc_md29}%
\Hypertarget{md_extra__doc_22__technicalities_autotoc_md29}%
\hypertarget{md_extra__doc_22__technicalities_autotoc_md30}{}\doxysection{\texorpdfstring{Visualization of Complex Objects}{Visualization of Complex Objects}}\label{md_extra__doc_22__technicalities_autotoc_md30}
The complex shapes of PMTs and other intricate objects may not render correctly with the default Open\+GL (OGL) visualization engine. To ensure the visualizer remains functional, these objects are set to invisible by default.

For a more detailed visualization that can handle complex geometries, you can use the Ray\+Tracer engine. While slower and more complex to use, Ray\+Tracer can visualize all volumes, regardless of their complexity. Here\textquotesingle{}s how to set it up\+:


\begin{DoxyItemize}
\item {\bfseries{Enable Ray\+Tracer\+:}}
\begin{DoxyItemize}
\item Open {\ttfamily common/data/vis/init\+\_\+vis.\+mac}
\item Comment out the line that loads {\ttfamily vis.\+mac}
\item Uncomment the line that loads {\ttfamily vis\+\_\+raytracer.\+mac}
\end{DoxyItemize}
\item {\bfseries{Make Objects Visible\+:}}
\begin{DoxyItemize}
\item Locate the visibility settings for the object you want to visualize
\item Change the condition that sets objects to invisible
\item Set the desired visibility attributes
\end{DoxyItemize}

Example for PMT glass visibility\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Original\ code}}
\DoxyCodeLine{\textcolor{keywordflow}{if}\ (m\_internalReflections\ \&\&\ \mbox{\hyperlink{class_o_m_sim_command_args_table_ac6f8ed95981671d5df9b029bcef93214}{OMSimCommandArgsTable::getInstance}}().get<bool>(\textcolor{stringliteral}{"{}visual"{}}))}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ logicalPMT-\/>SetVisAttributes(m\_invisibleVis);}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ ...\ other\ invisible\ settings\ ...}}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordflow}{else}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ logicalPMT-\/>SetVisAttributes(m\_glassVis);}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ ...\ other\ visible\ settings\ ...}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Modified\ code}}
\DoxyCodeLine{\textcolor{keywordflow}{if}\ (\textcolor{keyword}{false})\ \textcolor{comment}{//\ This\ condition\ will\ never\ be\ true,\ ensuring\ objects\ are\ always\ visible}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ ...\ invisible\ settings\ ...}}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordflow}{else}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ logicalPMT-\/>SetVisAttributes(m\_glassVis);}
\DoxyCodeLine{\ \ \ \ tubeVacuum-\/>SetVisAttributes(m\_airVis);}
\DoxyCodeLine{\ \ \ \ vacuumBackLogical-\/>SetVisAttributes(m\_airVis);}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ ...\ other\ visible\ settings\ ...}}
\DoxyCodeLine{\}}

\end{DoxyCode}

\item {\bfseries{Customize Ray\+Tracer Settings\+:}}
\begin{DoxyItemize}
\item Open {\ttfamily common/data/vis/vis\+\_\+raytracer.\+mac}
\item Adjust parameters such as\+:
\begin{DoxyItemize}
\item Viewing angle
\item Lighting conditions
\item Resolution
\item Background color
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md_extra__doc_22__technicalities_autotoc_md31}{}\doxysection{\texorpdfstring{The Tools namespace}{The Tools namespace}}\label{md_extra__doc_22__technicalities_autotoc_md31}
The tools namespace provide several methods that could help you. For example, {\ttfamily \doxylink{namespace_tools_aefa5ecd8f1fb3d69a65d517494e99669}{Tools\+::loadtxt}}, {\ttfamily \doxylink{namespace_tools_a052be79128cb3b90b6a4701455307246}{Tools\+::linspace}} and {\ttfamily \doxylink{namespace_tools_adf257eb5c348836614a3c10de47bcf6e}{Tools\+::logspace}} operate similarly to their Python\textquotesingle{}s numpy counterparts\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{_o_m_sim_tools_8hh}{OMSimTools.hh}}"{}}}
\DoxyCodeLine{std::vector<G4PV2DDataVector>\ lData\ =\ \mbox{\hyperlink{namespace_tools_aefa5ecd8f1fb3d69a65d517494e99669}{Tools::loadtxt}}(\textcolor{stringliteral}{"{}path/file\_name.txt"{}},\ \textcolor{keyword}{true});}
\DoxyCodeLine{std::vector<G4double>\ lFirstColumn\ =\ lData.at(0);}
\DoxyCodeLine{std::vector<G4double>\ lSecondColumn\ =\ lData.at(1);}
\DoxyCodeLine{}
\DoxyCodeLine{std::vector<double>\ lWavelengths\ =\ \mbox{\hyperlink{namespace_tools_a052be79128cb3b90b6a4701455307246}{Tools::linspace}}(275,\ 750,\ 96);}
\DoxyCodeLine{std::vector<double>\ lAbsLengths\ =\ \mbox{\hyperlink{namespace_tools_adf257eb5c348836614a3c10de47bcf6e}{Tools::logspace}}(-\/9,\ -\/4,\ 20);}
\DoxyCodeLine{}
\DoxyCodeLine{std::vector<double>\ data\ =\ \{1,\ 2,\ 2,\ 3,\ 3,\ 3,\ 4,\ 4,\ 5\};}
\DoxyCodeLine{\textcolor{keyword}{auto}\ [counts,\ edges]\ =\ \mbox{\hyperlink{namespace_tools_ab58e9ef8ed3fc6fe3cd85e26136f5be7}{Tools::histogram}}(data,\ 5);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ ...}}

\end{DoxyCode}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{md_extra__doc_22__technicalities_autotoc_md33}{}\doxysection{\texorpdfstring{Nomenclature}{Nomenclature}}\label{md_extra__doc_22__technicalities_autotoc_md33}
We follow these naming conventions\+:

Methods\+:
\begin{DoxyItemize}
\item Written in camel\+Case, starting with a lowercase letter
\item Example\+: {\ttfamily calculate\+Distance()}
\item Note\+: This contrasts with Geant4\textquotesingle{}s methods, which always start with an uppercase letter
\end{DoxyItemize}

Classes\+:
\begin{DoxyItemize}
\item Written in Pascal\+Case (also known as Upper\+Camel\+Case)
\item Core framework classes should start with {\ttfamily \doxylink{class_o_m_sim}{OMSim}}
\item Example\+: {\ttfamily \doxylink{class_o_m_sim_detector_construction}{OMSim\+Detector\+Construction}}
\end{DoxyItemize}

Namespaces
\begin{DoxyItemize}
\item Written in Pascal\+Case
\item Example\+: {\ttfamily Tools\+Namespace}
\end{DoxyItemize}

Member Variables\+:
\begin{DoxyItemize}
\item Prefix\+: {\ttfamily m\+\_\+}
\item Written in camel\+Case after the prefix
\item Example\+: {\ttfamily m\+\_\+particle\+Energy}
\end{DoxyItemize}

Global Variables\+:
\begin{DoxyItemize}
\item Prefix\+: {\ttfamily g\+\_\+}
\item Written in camel\+Case after the prefix
\item Example\+: {\ttfamily g\+\_\+world\+Volume}
\end{DoxyItemize}

Function Parameters\+:
\begin{DoxyItemize}
\item Prefix\+: {\ttfamily p\+\_\+}
\item Written in camel\+Case after the prefix
\item Example\+: {\ttfamily p\+\_\+initial\+Position}
\end{DoxyItemize}

Local Variables
\begin{DoxyItemize}
\item No prefix, written in camel\+Case
\item Example\+: {\ttfamily local\+Particle}
\end{DoxyItemize}

By adhering to these conventions, we aim to\+:
\begin{DoxyEnumerate}
\item Clearly distinguish \doxylink{class_o_m_sim}{OMSim} code from Geant4 code (so we can for example find+replace code without worries)
\item Easily identify the scope and purpose of variables and functions
\item Maintain consistency throughout the codebase, enhancing readability and maintainability
\end{DoxyEnumerate}

Remember to apply these conventions consistently across all new code and when refactoring existing code.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{md_extra__doc_22__technicalities_autotoc_md35}{}\doxysection{\texorpdfstring{Matching PMT to Measurements}{Matching PMT to Measurements}}\label{md_extra__doc_22__technicalities_autotoc_md35}
In order to simulate the PMT efficiency correctly, each photon is given a weight that corresponds to the detection probability (\href{md_extra_doc_0_common.html\#autotoc_md5}{\texttt{ click here}} for more details). These weights are calculated using data files to match measurements. These data files have to be generated for each new PMT that is to be added to the framework. The module {\ttfamily efficiency\+\_\+calibration} facilitates this procedure. In the following, the \doxylink{classm_d_o_m}{m\+DOM} PMT is used as an example.\hypertarget{md_extra__doc_22__technicalities_autotoc_md36}{}\doxysubsection{\texorpdfstring{Step 1\+: Fraction of absorbed photons}{Step 1: Fraction of absorbed photons}}\label{md_extra__doc_22__technicalities_autotoc_md36}
The optical properties (refractive index, thickness, and absorption length) of the glass tube and photocathode determine the number of photons absorbed in the photocathode. The optical properties of the photocathode (defined in file {\ttfamily Surf\+\_\+\+Generic\+\_\+\+Photocathode\+\_\+20nm.\+dat}) are from this paper \href{https://arxiv.org/abs/physics/0408075}{\texttt{ https\+://arxiv.\+org/abs/physics/0408075}} .

To calculate the quantum efficiency weight, we have to know how many photons are absorbed in the photocathode in the simulation. For this, go through the following steps\+:
\begin{DoxyItemize}
\item The most precise procedure is to simulate the beam used during the QE measurement (see for example {\ttfamily Beam\+::configure\+Erlangen\+QESetup} and {\ttfamily Beam\+::run\+Erlangen\+QEBeam} for the beam used in Erlangen). If you don\textquotesingle{}t know the divergence / beam size of the setup, you may use the one from Erlangen first.
\item In {\ttfamily OMSim\+\_\+efficiency\+\_\+calibration.\+cc} change the method {\ttfamily run\+QEbeam\+Simulation()} to use the newly defined beam instead of {\ttfamily run\+Erlangen\+QEBeam}. Define there also the wavelength range to be simulated.
\item Run the simulation with the following command, changing the PMT number to the one you want to simulate (make sure that your PMT is in the list in {\ttfamily \doxylink{class_o_m_sim_p_m_t_construction_a1a8373e9ae3095062edb477245133a9e}{OMSim\+PMTConstruction\+::select\+PMT}}, or hard code it in {\ttfamily OMSim\+Eff\+Cali\+Detector.\+cc}) 
\begin{DoxyCode}{0}
\DoxyCodeLine{./OMSim\_efficiency\_calibration\ -\/-\/pmt\_model\ 0\ -\/-\/simulation\_step\ 1\ -\/n\ 500000\ -\/-\/threads\ 4\ -\/-\/output\_file\ step1\ -\/-\/detector\_type\ 1}

\end{DoxyCode}

\item Check results and uncertainty. You want to determine the fraction pretty accurately, you may repeat the simulation at the UV region with higher statistics (change wavelength range in {\ttfamily run\+QEbeam\+Simulation()}).
\end{DoxyItemize}

To obtain the fraction I just run this python code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{wvs,\ h,\_\ =np.loadtxt(\textcolor{stringliteral}{"{}step1.dat"{}},\ unpack=1)}
\DoxyCodeLine{N=500000}
\DoxyCodeLine{err\ =\ np.sqrt(h)\ /\ N}
\DoxyCodeLine{h\ /=\ N}
\DoxyCodeLine{}
\DoxyCodeLine{plt.figure()}
\DoxyCodeLine{plt.errorbar(wvs,\ h,\ fmt=\textcolor{stringliteral}{"{}."{}},\ yerr\ =\ err,\ label\ =\textcolor{stringliteral}{"{}Absorbed\ photons"{}})}
\DoxyCodeLine{plt.ylabel(\textcolor{stringliteral}{"{}Fraction"{}})}
\DoxyCodeLine{plt.xlabel(\textcolor{stringliteral}{"{}Wavelength\ (nm)"{}})}
\DoxyCodeLine{plt.grid()}
\DoxyCodeLine{plt.legend()}
\DoxyCodeLine{np.savetxt(\textcolor{stringliteral}{"{}mDOM\_Hamamatsu\_R15458\_CT\_intrinsic\_QE.dat"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ np.array([wvs,\ h,\ err]).T,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ delimiter=\textcolor{stringliteral}{"{}\(\backslash\)t"{}},\ header=\textcolor{stringliteral}{"{}Wavelength(nm)\ \(\backslash\)t\ QE\ \(\backslash\)t\ error"{}})}

\end{DoxyCode}
 Here the results of the \doxylink{classm_d_o_m}{m\+DOM} PMT including its mean QE as comparison\+:

   ~\newline
  

\begin{quote}
{\bfseries{Note}}\+: Ensure that the (interpolated) QE of the PMT you intend to use is always smaller than the obtained absorbed fraction. If this is not the case you will have to change the optical properties of the photocathode and/or the tube glass! \end{quote}
If everything looks good, save the file (in the example above {\ttfamily m\+DOM\+\_\+\+Hamamatsu\+\_\+\+R15458\+\_\+\+CT\+\_\+intrinsic\+\_\+\+QE.\+dat}) in {\ttfamily common/data/\+PMTs/measurement\+\_\+matching\+\_\+data/\+QE/} and move to step 2.\hypertarget{md_extra__doc_22__technicalities_autotoc_md37}{}\doxysubsection{\texorpdfstring{Step 2\+: Expand OMSim\+PMTResponse and Verify QE}{Step 2: Expand OMSimPMTResponse and Verify QE}}\label{md_extra__doc_22__technicalities_autotoc_md37}
Add the path to the created file in your PMT file under the key {\ttfamily j\+Absorbed\+Fraction\+File\+Name} and also a default QE file under the key {\ttfamily j\+Default\+QEFile\+Name} (check {\ttfamily pmt\+\_\+\+Hamamatsu\+\_\+\+R15458\+\_\+\+CAT.\+dat} for guidance).

Now run the simulation again 
\begin{DoxyCode}{0}
\DoxyCodeLine{./OMSim\_efficiency\_calibration\ -\/-\/pmt\_model\ 0\ -\/-\/simulation\_step\ 2\ -\/n\ 100000\ -\/-\/threads\ 4\ -\/-\/output\_file\ step2\ -\/-\/detector\_type\ 1}

\end{DoxyCode}


and check that the weights are being calculated correctly


\begin{DoxyCode}{0}
\DoxyCodeLine{wvs,\ h,\ w\ =np.loadtxt(\textcolor{stringliteral}{"{}step2.dat"{}},\ unpack=1)}
\DoxyCodeLine{N=100000}
\DoxyCodeLine{err\ =\ np.sqrt(h)*w/N**2}
\DoxyCodeLine{h\ /=\ N}
\DoxyCodeLine{w\ /=\ N}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{plt.figure()}
\DoxyCodeLine{plt.errorbar(wvs,\ w,\ fmt=\textcolor{stringliteral}{"{}."{}},\ yerr\ =\ err,\ label\ =\textcolor{stringliteral}{"{}Mean\ sum\ of\ photon\ weights\ Geant4"{}})}
\DoxyCodeLine{plt.xlabel(\textcolor{stringliteral}{"{}Wavelength\ (nm)"{}})}
\DoxyCodeLine{plt.grid()}
\DoxyCodeLine{plt.legend()}

\end{DoxyCode}


   ~\newline
  \hypertarget{md_extra__doc_22__technicalities_autotoc_md38}{}\doxysubsection{\texorpdfstring{Step 3\+: Matching detection efficiency scan}{Step 3: Matching detection efficiency scan}}\label{md_extra__doc_22__technicalities_autotoc_md38}
The next step is to create the collection efficiency weights to match the relative detection efficiency scans. For this the scan measurement is replicated in the simulation, scanning the PMT in a XY grid. The output file of the simulation of this step is a histogram with the position of absorbed photons for each beam position.


\begin{DoxyItemize}
\item As before, we have to simulate the beam used during the scan measurement (see for example {\ttfamily Beam\+::configure\+XYZScan\+\_\+\+Pico\+Quant\+Setup} and {\ttfamily Beam\+::run\+Beam\+Pico\+Quant\+Setup} for the beam used in Münster)
\item In common/data/\+PMTs/measurement\+\_\+matching\+\_\+data/setup\+\_\+stuff you will find the radius vs distance file from the measurement which you might need to adjust (e.\+g. newz = z\mbox{[}-\/1\mbox{]} -\/ z + get\+Distance\+PMTCenter\+To\+Tip() your PMT -\/ get\+Distance\+PMTCenter\+To\+Tip() \doxylink{classm_d_o_m}{m\+DOM} PMT) -\/ see \doxylink{classm_d_o_m}{m\+DOM} PMT file for reference. Make sure to use this file in \textquotesingle{}configure\+ZCorrection\+\_\+\+Pico\+Quant\textquotesingle{} under \textquotesingle{}simulations/efficiency\+\_\+calibration/src/\+OMSim\+Beam.\+cc\textquotesingle{}. Under \textquotesingle{}Beam\+::run\+Beam\+Pico\+Quant\+Setup\textquotesingle{} change the minimal distance (if (z\texorpdfstring{$<$}{<}4.\+8) \{ z = 4.\+8;\}).
\item In in {\ttfamily run\+XYZfrontal\+Scan()} of {\ttfamily OMSim\+\_\+efficiency\+\_\+calibration.\+cc} change the scan range ({\ttfamily grid} vector) and radius limit ({\ttfamily r\+Lim}) according to the diameter of your PMT
\item Also adjust the binning of the output histogram in {\ttfamily OMSim\+Effi\+Cali\+Analyisis\+::write\+Hit\+Position\+Histogram}
\item You can check if the distance is correct by running the following command and including e.\+g. scanner-\/\texorpdfstring{$>$}{>}run\+Beam\+Pico\+Quant\+Setup(0, 0); in \textquotesingle{}run\+XYZfrontal\+Scan()\textquotesingle{} 
\begin{DoxyCode}{0}
\DoxyCodeLine{./OMSim\_efficiency\_calibration\ -\/-\/detector\_type\ 1\ -\/-\/pmt\_model\ 0\ -\/v\ -\/-\/simulation\_step\ 3\ -\/-\/simple\_PMT}
\DoxyCodeLine{/vis/scene/add/axes\ 0\ 0\ 0\ 30\ mm\ \#example}
\DoxyCodeLine{/run/beamOn\ 10}

\end{DoxyCode}

\item Run the XY grid simulation. 10000 photons per grid position should be enough, but you may increase / decrease statistics as you want 
\begin{DoxyCode}{0}
\DoxyCodeLine{./OMSim\_efficiency\_calibration\ -\/-\/pmt\_model\ 0\ -\/-\/simulation\_step\ 3\ -\/n\ 10000\ -\/-\/threads\ 4\ -\/-\/output\_file\ step3\ -\/-\/detector\_type\ 1}

\end{DoxyCode}

\item Fit the weights using simulation data. The analysis done for the \doxylink{classm_d_o_m}{m\+DOM} can be found in the notebook located in {\ttfamily documentation/notebooks/detection\+\_\+efficiency\+\_\+matching/}.
\item Save the weights in a file and store it in {\ttfamily common/data/\+PMTs/measurement\+\_\+matching\+\_\+data/\+CE\+\_\+weight/}
\item Add to this file in the PMT data file under the key {\ttfamily j\+CEweights\+File\+Name}.
\item Run the simulation again and check if the weights are correct.
\end{DoxyItemize}\hypertarget{md_extra__doc_22__technicalities_autotoc_md39}{}\doxysubsection{\texorpdfstring{Step 4\+: Matching gain / transit time scans}{Step 4: Matching gain / transit time scans}}\label{md_extra__doc_22__technicalities_autotoc_md39}
The scan data of transit time / gain must be corrected before use, as the coordinates of the beam do not necessarily correspond to the primary spot on the photocathode that is illuminated, since air-\/glass boundary refracts the beam.


\begin{DoxyItemize}
\item As before, we have to simulate the beam used during the scan measurement.
\item Change the profile vector and r\+Lim in {\ttfamily runfrontal\+Profile\+Scann\+NKT()} under {\ttfamily simulations/efficiency\+\_\+calibration/\+OMSim\+\_\+efficiency\+\_\+calibration.\+cc}
\item Run the XY grid simulation {\bfseries{using the simple PMT}}, check the function being used under step 4
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{./OMSim\_efficiency\_calibration\ -\/-\/simple\_PMT\ -\/-\/pmt\_model\ 0\ -\/-\/simulation\_step\ 4\ -\/n\ 100000\ -\/-\/threads\ 4\ -\/-\/output\_file\ step4\ -\/-\/detector\_type\ 1}

\end{DoxyCode}

\begin{DoxyItemize}
\item Follow the analysis in the notebook {\ttfamily documentation/notebooks/scans\+\_\+matching/} and save the created files in {\ttfamily common/data/\+PMTs/measurement\+\_\+matching\+\_\+data/scans/}. Note that \doxylink{class_o_m_sim}{OMSim} expects a naming convention for these files (see {\ttfamily OMSim\+PMTResponse\+::make\+Scans\+Interpolators}).
\item Add the vector with scanned wavelengths in PMT file with the key {\ttfamily j\+Scanned\+Wavelengths} and add the path with the newly created scan files under the key {\ttfamily j\+Scan\+Data\+Path} (check {\ttfamily pmt\+\_\+\+Hamamatsu\+\_\+\+R15458\+\_\+\+CAT.\+dat} for guidance).
\item Run the simulation in step 5 (modify method before accordingly) to check the output with the newly introduced files
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{./OMSim\_efficiency\_calibration\ -\/-\/pmt\_model\ 0\ -\/-\/simulation\_step\ 5\ -\/n\ 10000\ -\/-\/threads\ 4\ -\/-\/output\_file\ step5\ -\/-\/detector\_type\ 1}

\end{DoxyCode}


If you need to add more parameters (for example low gain probability, which is also photocathode position dependent and yet to be implemented), you will have to add a new interpolator map and {\ttfamily OMSim\+PMTResponse\+::make\+Scans\+Interpolators} accordingly.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 