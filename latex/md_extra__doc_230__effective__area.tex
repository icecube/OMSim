\chapter{\texorpdfstring{$>$}{>} Effective Area Studies}
\hypertarget{md_extra__doc_230__effective__area}{}\label{md_extra__doc_230__effective__area}\index{$>$ Effective Area Studies@{$>$ Effective Area Studies}}
\label{md_extra__doc_230__effective__area_autotoc_md46}%
\Hypertarget{md_extra__doc_230__effective__area_autotoc_md46}%


In the folder {\ttfamily simulations/effective\+\_\+area} you find the files pertinent to the effective area studies.\hypertarget{md_extra__doc_230__effective__area_autotoc_md47}{}\doxysection{\texorpdfstring{Introduction to effective areas}{Introduction to effective areas}}\label{md_extra__doc_230__effective__area_autotoc_md47}
\begin{quote}
{\bfseries{Note}}\+: In the following, a short introduction of an effective area study is made with the \doxylink{classm_d_o_m}{m\+DOM} as an example. For further details see Chapter 10 of \href{https://www.uni-muenster.de/imperia/md/content/physik_kp/agkappes/abschlussarbeiten/doktorarbeiten/1702-phd_lclassen.pdf}{\texttt{ Lew Classen\textquotesingle{}s thesis}} or Section 9.\+3.\+5 of \href{https://zenodo.org/record/8121321}{\texttt{ Martin Unland\textquotesingle{}s thesis}}. \end{quote}
During the design of a module, its sensitivity is optimised by considering the optical properties of various materials and altering the geometry and positioning of the mechanical components in the Geant4 simulation.

The metric to optimise the module\textquotesingle{}s sensitivity is the effective area A\+\_\+eff(θ, φ). This represents the area that is detected from a plane wave of incidence angle of θ (zenith) and φ (azimuth) with respect to the module. This parameter is calculated with \doxylink{class_o_m_sim}{OMSim} by simulating a disk emitting mono-\/energetic photons perpendicular to its surface with a uniform density profile.

The photon generation is made with the module {\ttfamily \doxylink{class_angular_scan}{Angular\+Scan}}, running the method {\ttfamily \doxylink{class_angular_scan_a465f642ebbe30fc94f9ed8ec6e554ef4}{Angular\+Scan\+::run\+Single\+Angular\+Scan}} once for each direction to be investigated.

   ~\newline
 Figure 1\+: {\itshape Screenshot of an \doxylink{classm_d_o_m}{m\+DOM} illuminated by a disk emitter simulating the incidence of a plane wave from the direction θ (zenith) and φ (azimuth) using the Geant4 visualiser. The photon trajectories are represented by orange lines, and yellow dots mark the locations of physical interactions. Image taken from \href{https://zenodo.org/record/8121321}{\texttt{ this thesis}}.}  

After simulating N photons from a plane of area A\+\_\+rad (which has to be larger than the projected area of the \doxylink{classm_d_o_m}{m\+DOM}), the effective area is calculated as

\$\$ A\+\_\+\{\textbackslash{}mathrm\{eff\}\}(\textbackslash{}theta, \textbackslash{}phi) = \textbackslash{}frac\{N\+\_\+\{\textbackslash{}mathrm\{det\}\}(\textbackslash{}theta, \textbackslash{}phi)\}\{N\}\textbackslash{}cdot A\+\_\+\{\textbackslash{}mathrm\{rad\}\}, \$\$

where N\+\_\+det is the number of photons detected by the module. To optimise the sensitivity over multiple directions, A\+\_\+eff(θ, φ) is calculated for various angle pairs, and the mean effective area, A\+\_\+eff\+\_\+mean, is determined. The n angle pairs are chosen using healpix, which separates a sphere into n pixels of equal area. Thus,

\$\$ \textbackslash{}overline\{A\}\+\_\+\{\textbackslash{}mathrm\{eff\}\} = \textbackslash{}frac\{1\}\{n\}\textbackslash{}sum\+\_\+\{i=1\}\texorpdfstring{$^\wedge$}{\string^}n A\+\_\+\{\textbackslash{}mathrm\{eff\}\}(\textbackslash{}theta\+\_\+i, \textbackslash{}phi\+\_\+i). \$\$

Since the effective area is wavelength dependent, the calculation must be repeated for different wavelengths. Wavelengths shorter than 300nm are absorbed by the pressure vessel, whereas the QE of the PMT approaches zero at wavelengths longer than 700nm.\hypertarget{md_extra__doc_230__effective__area_autotoc_md48}{}\doxysection{\texorpdfstring{Example using healpy}{Example using healpy}}\label{md_extra__doc_230__effective__area_autotoc_md48}
In the following, an example of the usage of the effective area module is given. Although there are C++ healpix libraries, in my opinion, the easiest way of getting the angle pair coordinates is using Healpy in Python.

In principle, for short simulations, you could run the program directly from Python using the angles from healpy as input parameters\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{import}\ healpy\ \textcolor{keyword}{as}\ hp}
\DoxyCodeLine{\textcolor{keyword}{import}\ numpy\ \textcolor{keyword}{as}\ np}
\DoxyCodeLine{\textcolor{keyword}{from}\ os\ \textcolor{keyword}{import}\ system}
\DoxyCodeLine{}
\DoxyCodeLine{NSIDE\ =\ 8\ \textcolor{comment}{\#only\ powers\ of\ 2\ allowed,\ the\ larger,\ the\ more\ pixels\ are\ calculated}}
\DoxyCodeLine{NPIX\ =\ hp.nside2npix(NSIDE)}
\DoxyCodeLine{thetas,\ phis\ =\ np.degrees(hp.pix2ang(nside=NSIDE,\ ipix=np.arange(NPIX)))}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{for}\ i,\ (theta,\ phi)\ \textcolor{keywordflow}{in}\ enumerate(zip(thetas,\ phis)):}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{if}\ i==0:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ system(f\textcolor{stringliteral}{"{}./OMSim\_effective\_area\ -\/n\ 10000\ -\/-\/environment\ 1\ -\/r\ 300\ -\/t\ \{theta\}\ -\/f\ \ \{phi\}\ -\/-\/output\_file\ output"{}})}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{else}:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ system(f\textcolor{stringliteral}{"{}./OMSim\_effective\_area\ -\/n\ 10000\ -\/-\/environment\ 1\ -\/r\ 300\ -\/t\ \{theta\}\ -\/f\ \ \{phi\}\ -\/-\/output\_file\ output\ -\/-\/no\_header"{}})}

\end{DoxyCode}


However, this is quite inefficient. The best is to save the angle pairs into a file and pass it as an argument. If you give a file as an argument, the arg theta and phi are ignored.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{import}\ healpy\ \textcolor{keyword}{as}\ hp}
\DoxyCodeLine{\textcolor{keyword}{import}\ numpy\ \textcolor{keyword}{as}\ np}
\DoxyCodeLine{\textcolor{keyword}{from}\ os\ \textcolor{keyword}{import}\ system}
\DoxyCodeLine{}
\DoxyCodeLine{NSIDE\ =\ 8\ \textcolor{comment}{\#only\ powers\ of\ 2\ allowed,\ the\ larger,\ the\ more\ pixels\ are\ calculated}}
\DoxyCodeLine{NPIX\ =\ hp.nside2npix(NSIDE)}
\DoxyCodeLine{thetas,\ phis\ =\ np.degrees(hp.pix2ang(nside=NSIDE,\ ipix=np.arange(NPIX)))}
\DoxyCodeLine{fname\ =\ \textcolor{stringliteral}{"{}angle\_pairs.txt"{}}}
\DoxyCodeLine{np.savetxt(fname,\ np.column\_stack((thetas,\ phis)))}
\DoxyCodeLine{system(f\textcolor{stringliteral}{"{}./OMSim\_effective\_area\ -\/n\ 10000\ -\/-\/environment\ 1\ -\/r\ 300\ -\/-\/angles\_file\ \{fname\}\ -\/-\/output\_file\ output"{}})}

\end{DoxyCode}


In my PC, the first code block needs 51 seconds (tested with NSIDE=2), the second block only 14 seconds (as simulation has to be initialised only once). 