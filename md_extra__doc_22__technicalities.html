<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="light-mode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OMSim: Technicalities for Developers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/svg+xml" href="logo.drawio.svg"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/icecube/OMSim" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logotest.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OMSim
   </div>
   <div id="projectbrief">Geant4 for IceCube optical module studies</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_extra__doc_22__technicalities.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Technicalities for Developers</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md30">Visualization of Complex Objects</a></li>
<li class="level1"><a href="#autotoc_md31">The Tools namespace</a></li>
<li class="level1"><a href="#autotoc_md33">Nomenclature</a></li>
<li class="level1"><a href="#autotoc_md35">Matching PMT to Measurements</a><ul><li class="level2"><a href="#autotoc_md36">Step 1: Fraction of absorbed photons</a></li>
<li class="level2"><a href="#autotoc_md37">Step 2: Expand OMSimPMTResponse and Verify QE</a></li>
<li class="level2"><a href="#autotoc_md38">Step 3: Matching detection efficiency scan</a></li>
<li class="level2"><a href="#autotoc_md39">Step 4: Matching gain / transit time scans</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="autotoc_md29"></a></p>
<h1><a class="anchor" id="autotoc_md30"></a>
Visualization of Complex Objects</h1>
<p>The complex shapes of PMTs and other intricate objects may not render correctly with the default OpenGL (OGL) visualization engine. To ensure the visualizer remains functional, these objects are set to invisible by default.</p>
<p>For a more detailed visualization that can handle complex geometries, you can use the RayTracer engine. While slower and more complex to use, RayTracer can visualize all volumes, regardless of their complexity. Here's how to set it up:</p>
<ul>
<li><b>Enable RayTracer:</b><ul>
<li>Open <code>common/data/vis/init_vis.mac</code></li>
<li>Comment out the line that loads <code>vis.mac</code></li>
<li>Uncomment the line that loads <code>vis_raytracer.mac</code></li>
</ul>
</li>
<li><p class="startli"><b>Make Objects Visible:</b></p><ul>
<li>Locate the visibility settings for the object you want to visualize</li>
<li>Change the condition that sets objects to invisible</li>
<li>Set the desired visibility attributes</li>
</ul>
<p class="startli">Example for PMT glass visibility:</p>
<div class="fragment"><div class="line"><span class="comment">// Original code</span></div>
<div class="line"><span class="keywordflow">if</span> (m_internalReflections &amp;&amp; <a class="code hl_function" href="class_o_m_sim_command_args_table.html#ac6f8ed95981671d5df9b029bcef93214">OMSimCommandArgsTable::getInstance</a>().get&lt;bool&gt;(<span class="stringliteral">&quot;visual&quot;</span>))</div>
<div class="line">{</div>
<div class="line">    logicalPMT-&gt;SetVisAttributes(m_invisibleVis);</div>
<div class="line">    <span class="comment">// ... other invisible settings ...</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    logicalPMT-&gt;SetVisAttributes(m_glassVis);</div>
<div class="line">    <span class="comment">// ... other visible settings ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Modified code</span></div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">false</span>) <span class="comment">// This condition will never be true, ensuring objects are always visible</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ... invisible settings ...</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    logicalPMT-&gt;SetVisAttributes(m_glassVis);</div>
<div class="line">    tubeVacuum-&gt;SetVisAttributes(m_airVis);</div>
<div class="line">    vacuumBackLogical-&gt;SetVisAttributes(m_airVis);</div>
<div class="line">    <span class="comment">// ... other visible settings ...</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_o_m_sim_command_args_table_html_ac6f8ed95981671d5df9b029bcef93214"><div class="ttname"><a href="class_o_m_sim_command_args_table.html#ac6f8ed95981671d5df9b029bcef93214">OMSimCommandArgsTable::getInstance</a></div><div class="ttdeci">static OMSimCommandArgsTable &amp; getInstance()</div><div class="ttdef"><b>Definition</b> OMSimCommandArgsTable.cc:7</div></div>
</div><!-- fragment --></li>
<li><b>Customize RayTracer Settings:</b><ul>
<li>Open <code>common/data/vis/vis_raytracer.mac</code></li>
<li>Adjust parameters such as:<ul>
<li>Viewing angle</li>
<li>Lighting conditions</li>
<li>Resolution</li>
<li>Background color</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md31"></a>
The Tools namespace</h1>
<p>The tools namespace provide several methods that could help you. For example, <code><a class="el" href="namespace_tools.html#aefa5ecd8f1fb3d69a65d517494e99669" title="Reads numerical data from a file and returns it as a 2D vector. Similar to numpy.loadtxt.">Tools::loadtxt</a></code>, <code><a class="el" href="namespace_tools.html#a052be79128cb3b90b6a4701455307246" title="Generates a linearly spaced vector.">Tools::linspace</a></code> and <code><a class="el" href="namespace_tools.html#adf257eb5c348836614a3c10de47bcf6e" title="Generates a logarithmically spaced vector.">Tools::logspace</a></code> operate similarly to their Python's numpy counterparts:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_o_m_sim_tools_8hh.html">OMSimTools.hh</a>&quot;</span></div>
<div class="line">std::vector&lt;G4PV2DDataVector&gt; lData = <a class="code hl_function" href="namespace_tools.html#aefa5ecd8f1fb3d69a65d517494e99669">Tools::loadtxt</a>(<span class="stringliteral">&quot;path/file_name.txt&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line">std::vector&lt;G4double&gt; lFirstColumn = lData.at(0);</div>
<div class="line">std::vector&lt;G4double&gt; lSecondColumn = lData.at(1);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;double&gt; lWavelengths = <a class="code hl_function" href="namespace_tools.html#a052be79128cb3b90b6a4701455307246">Tools::linspace</a>(275, 750, 96);</div>
<div class="line">std::vector&lt;double&gt; lAbsLengths = <a class="code hl_function" href="namespace_tools.html#adf257eb5c348836614a3c10de47bcf6e">Tools::logspace</a>(-9, -4, 20);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;double&gt; data = {1, 2, 2, 3, 3, 3, 4, 4, 5};</div>
<div class="line"><span class="keyword">auto</span> [counts, edges] = <a class="code hl_function" href="namespace_tools.html#ab58e9ef8ed3fc6fe3cd85e26136f5be7">Tools::histogram</a>(data, 5);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="ttc" id="a_o_m_sim_tools_8hh_html"><div class="ttname"><a href="_o_m_sim_tools_8hh.html">OMSimTools.hh</a></div><div class="ttdoc">Definition of Tools namespace, a collection of helper methods.</div></div>
<div class="ttc" id="anamespace_tools_html_a052be79128cb3b90b6a4701455307246"><div class="ttname"><a href="namespace_tools.html#a052be79128cb3b90b6a4701455307246">Tools::linspace</a></div><div class="ttdeci">std::vector&lt; double &gt; linspace(double start, double end, int num_points, bool endpoint=true)</div><div class="ttdoc">Generates a linearly spaced vector.</div><div class="ttdef"><b>Definition</b> OMSimTools.cc:330</div></div>
<div class="ttc" id="anamespace_tools_html_ab58e9ef8ed3fc6fe3cd85e26136f5be7"><div class="ttname"><a href="namespace_tools.html#ab58e9ef8ed3fc6fe3cd85e26136f5be7">Tools::histogram</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; histogram(const std::vector&lt; double &gt; &amp;data, const std::variant&lt; int, std::vector&lt; double &gt; &gt; &amp;bins=10, const std::optional&lt; std::pair&lt; double, double &gt; &gt; &amp;range=std::nullopt, const std::vector&lt; double &gt; &amp;weights=std::vector&lt; double &gt;())</div><div class="ttdoc">Compute the histogram of a dataset.</div><div class="ttdef"><b>Definition</b> OMSimTools.cc:161</div></div>
<div class="ttc" id="anamespace_tools_html_adf257eb5c348836614a3c10de47bcf6e"><div class="ttname"><a href="namespace_tools.html#adf257eb5c348836614a3c10de47bcf6e">Tools::logspace</a></div><div class="ttdeci">std::vector&lt; double &gt; logspace(double start, double end, int num_points, double base=10.0, bool endpoint=true)</div><div class="ttdoc">Generates a logarithmically spaced vector.</div><div class="ttdef"><b>Definition</b> OMSimTools.cc:364</div></div>
<div class="ttc" id="anamespace_tools_html_aefa5ecd8f1fb3d69a65d517494e99669"><div class="ttname"><a href="namespace_tools.html#aefa5ecd8f1fb3d69a65d517494e99669">Tools::loadtxt</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; double &gt; &gt; loadtxt(const std::string &amp;pFilePath, bool pUnpack=true, size_t pSkipRows=0, char pDelimiter=' ', char pComments='#')</div><div class="ttdoc">Reads numerical data from a file and returns it as a 2D vector. Similar to numpy.loadtxt.</div><div class="ttdef"><b>Definition</b> OMSimTools.cc:264</div></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="autotoc_md33"></a>
Nomenclature</h1>
<p>We follow these naming conventions:</p>
<p>Methods:</p><ul>
<li>Written in camelCase, starting with a lowercase letter</li>
<li>Example: <code>calculateDistance()</code></li>
<li>Note: This contrasts with Geant4's methods, which always start with an uppercase letter</li>
</ul>
<p>Classes:</p><ul>
<li>Written in PascalCase (also known as UpperCamelCase)</li>
<li>Core framework classes should start with <code><a class="el" href="class_o_m_sim.html" title="Controls the main simulation process.">OMSim</a></code></li>
<li>Example: <code><a class="el" href="class_o_m_sim_detector_construction.html" title="Class for detector construction in the effective area simulation.">OMSimDetectorConstruction</a></code></li>
</ul>
<p>Namespaces</p><ul>
<li>Written in PascalCase</li>
<li>Example: <code>ToolsNamespace</code></li>
</ul>
<p>Member Variables:</p><ul>
<li>Prefix: <code>m_</code></li>
<li>Written in camelCase after the prefix</li>
<li>Example: <code>m_particleEnergy</code></li>
</ul>
<p>Global Variables:</p><ul>
<li>Prefix: <code>g_</code></li>
<li>Written in camelCase after the prefix</li>
<li>Example: <code>g_worldVolume</code></li>
</ul>
<p>Function Parameters:</p><ul>
<li>Prefix: <code>p_</code></li>
<li>Written in camelCase after the prefix</li>
<li>Example: <code>p_initialPosition</code></li>
</ul>
<p>Local Variables</p><ul>
<li>No prefix, written in camelCase</li>
<li>Example: <code>localParticle</code></li>
</ul>
<p>By adhering to these conventions, we aim to:</p><ol type="1">
<li>Clearly distinguish <a class="el" href="class_o_m_sim.html" title="Controls the main simulation process.">OMSim</a> code from Geant4 code (so we can for example find+replace code without worries)</li>
<li>Easily identify the scope and purpose of variables and functions</li>
<li>Maintain consistency throughout the codebase, enhancing readability and maintainability</li>
</ol>
<p>Remember to apply these conventions consistently across all new code and when refactoring existing code.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="autotoc_md35"></a>
Matching PMT to Measurements</h1>
<p>In order to simulate the PMT efficiency correctly, each photon is given a weight that corresponds to the detection probability (<a href="md_extra_doc_0_common.html#autotoc_md5">click here</a> for more details). These weights are calculated using data files to match measurements. These data files have to be generated for each new PMT that is to be added to the framework. The module <code>efficiency_calibration</code> facilitates this procedure. In the following, the <a class="el" href="classm_d_o_m.html">mDOM</a> PMT is used as an example.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Step 1: Fraction of absorbed photons</h2>
<p>The optical properties (refractive index, thickness, and absorption length) of the glass tube and photocathode determine the number of photons absorbed in the photocathode. The optical properties of the photocathode (defined in file <code>Surf_Generic_Photocathode_20nm.dat</code>) are from this paper <a href="https://arxiv.org/abs/physics/0408075">https://arxiv.org/abs/physics/0408075</a> .</p>
<p>To calculate the quantum efficiency weight, we have to know how many photons are absorbed in the photocathode in the simulation. For this, go through the following steps:</p><ul>
<li>The most precise procedure is to simulate the beam used during the QE measurement (see for example <code>Beam::configureErlangenQESetup</code> and <code>Beam::runErlangenQEBeam</code> for the beam used in Erlangen). If you don't know the divergence / beam size of the setup, you may use the one from Erlangen first.</li>
<li>In <code>OMSim_efficiency_calibration.cc</code> change the method <code>runQEbeamSimulation()</code> to use the newly defined beam instead of <code>runErlangenQEBeam</code>. Define there also the wavelength range to be simulated.</li>
<li>Run the simulation with the following command, changing the PMT number to the one you want to simulate (make sure that your PMT is in the list in <code><a class="el" href="class_o_m_sim_p_m_t_construction.html#a1a8373e9ae3095062edb477245133a9e">OMSimPMTConstruction::selectPMT</a></code>, or hard code it in <code>OMSimEffCaliDetector.cc</code>) <div class="fragment"><div class="line">./OMSim_efficiency_calibration --pmt_model 0 --simulation_step 1 -n 500000 --threads 4 --output_file step1 --detector_type 1</div>
</div><!-- fragment --></li>
<li>Check results and uncertainty. You want to determine the fraction pretty accurately, you may repeat the simulation at the UV region with higher statistics (change wavelength range in <code>runQEbeamSimulation()</code>).</li>
</ul>
<p>To obtain the fraction I just run this python code:</p>
<div class="fragment"><div class="line">wvs, h,_ =np.loadtxt(<span class="stringliteral">&quot;step1.dat&quot;</span>, unpack=1)</div>
<div class="line">N=500000</div>
<div class="line">err = np.sqrt(h) / N</div>
<div class="line">h /= N</div>
<div class="line"> </div>
<div class="line">plt.figure()</div>
<div class="line">plt.errorbar(wvs, h, fmt=<span class="stringliteral">&quot;.&quot;</span>, yerr = err, label =<span class="stringliteral">&quot;Absorbed photons&quot;</span>)</div>
<div class="line">plt.ylabel(<span class="stringliteral">&quot;Fraction&quot;</span>)</div>
<div class="line">plt.xlabel(<span class="stringliteral">&quot;Wavelength (nm)&quot;</span>)</div>
<div class="line">plt.grid()</div>
<div class="line">plt.legend()</div>
<div class="line">np.savetxt(<span class="stringliteral">&quot;mDOM_Hamamatsu_R15458_CT_intrinsic_QE.dat&quot;</span>,</div>
<div class="line">           np.array([wvs, h, err]).T,</div>
<div class="line">           delimiter=<span class="stringliteral">&quot;\t&quot;</span>, header=<span class="stringliteral">&quot;Wavelength(nm) \t QE \t error&quot;</span>)</div>
</div><!-- fragment --><p> Here the results of the <a class="el" href="classm_d_o_m.html">mDOM</a> PMT including its mean QE as comparison:</p>
<div style="width: 100%; text-align: center;"> <img src="step1_results_mdom.png" alt="" width="450" height="320" class="inline"/> <div style="width: 80%; margin: auto;"> <br  />
 </div> </div><blockquote class="doxtable">
<p>&zwj;<b>Note</b>: Ensure that the (interpolated) QE of the PMT you intend to use is always smaller than the obtained absorbed fraction. If this is not the case you will have to change the optical properties of the photocathode and/or the tube glass! </p>
</blockquote>
<p>If everything looks good, save the file (in the example above <code>mDOM_Hamamatsu_R15458_CT_intrinsic_QE.dat</code>) in <code>common/data/PMTs/measurement_matching_data/QE/</code> and move to step 2.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Step 2: Expand OMSimPMTResponse and Verify QE</h2>
<p>Add the path to the created file in your PMT file under the key <code>jAbsorbedFractionFileName</code> and also a default QE file under the key <code>jDefaultQEFileName</code> (check <code>pmt_Hamamatsu_R15458_CAT.dat</code> for guidance).</p>
<p>Now run the simulation again </p><div class="fragment"><div class="line">./OMSim_efficiency_calibration --pmt_model 0 --simulation_step 2 -n 100000 --threads 4 --output_file step2 --detector_type 1</div>
</div><!-- fragment --><p>and check that the weights are being calculated correctly</p>
<div class="fragment"><div class="line">wvs, h, w =np.loadtxt(<span class="stringliteral">&quot;step2.dat&quot;</span>, unpack=1)</div>
<div class="line">N=100000</div>
<div class="line">err = np.sqrt(h)*w/N**2</div>
<div class="line">h /= N</div>
<div class="line">w /= N</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">plt.figure()</div>
<div class="line">plt.errorbar(wvs, w, fmt=<span class="stringliteral">&quot;.&quot;</span>, yerr = err, label =<span class="stringliteral">&quot;Mean sum of photon weights Geant4&quot;</span>)</div>
<div class="line">plt.xlabel(<span class="stringliteral">&quot;Wavelength (nm)&quot;</span>)</div>
<div class="line">plt.grid()</div>
<div class="line">plt.legend()</div>
</div><!-- fragment --><div style="width: 100%; text-align: center;"> <img src="step2_qe.png" alt="" width="450" height="320" class="inline"/> <div style="width: 80%; margin: auto;"> <br  />
 </div> </div><h2><a class="anchor" id="autotoc_md38"></a>
Step 3: Matching detection efficiency scan</h2>
<p>The next step is to create the collection efficiency weights to match the relative detection efficiency scans. For this the scan measurement is replicated in the simulation, scanning the PMT in a XY grid. The output file of the simulation of this step is a histogram with the position of absorbed photons for each beam position.</p>
<ul>
<li>As before, we have to simulate the beam used during the scan measurement (see for example <code>Beam::configureXYZScan_PicoQuantSetup</code> and <code>Beam::runBeamPicoQuantSetup</code> for the beam used in Münster)</li>
<li>In common/data/PMTs/measurement_matching_data/setup_stuff you will find the radius vs distance file from the measurement which you might need to adjust (e.g. newz = z[-1] - z + getDistancePMTCenterToTip() your PMT - getDistancePMTCenterToTip() <a class="el" href="classm_d_o_m.html">mDOM</a> PMT) - see <a class="el" href="classm_d_o_m.html">mDOM</a> PMT file for reference. Make sure to use this file in 'configureZCorrection_PicoQuant' under 'simulations/efficiency_calibration/src/OMSimBeam.cc'. Under 'Beam::runBeamPicoQuantSetup' change the minimal distance (if (z&lt;4.8) { z = 4.8;}).</li>
<li>In in <code>runXYZfrontalScan()</code> of <code>OMSim_efficiency_calibration.cc</code> change the scan range (<code>grid</code> vector) and radius limit (<code>rLim</code>) according to the diameter of your PMT</li>
<li>Also adjust the binning of the output histogram in <code>OMSimEffiCaliAnalyisis::writeHitPositionHistogram</code></li>
<li>You can check if the distance is correct by running the following command and including e.g. scanner-&gt;runBeamPicoQuantSetup(0, 0); in 'runXYZfrontalScan()' <div class="fragment"><div class="line">./OMSim_efficiency_calibration --detector_type 1 --pmt_model 0 -v --simulation_step 3 --simple_PMT</div>
<div class="line">/vis/scene/add/axes 0 0 0 30 mm #example</div>
<div class="line">/run/beamOn 10</div>
</div><!-- fragment --></li>
<li>Run the XY grid simulation. 10000 photons per grid position should be enough, but you may increase / decrease statistics as you want <div class="fragment"><div class="line">./OMSim_efficiency_calibration --pmt_model 0 --simulation_step 3 -n 10000 --threads 4 --output_file step3 --detector_type 1</div>
</div><!-- fragment --></li>
<li>Fit the weights using simulation data. The analysis done for the <a class="el" href="classm_d_o_m.html">mDOM</a> can be found in the notebook located in <code>documentation/notebooks/detection_efficiency_matching/</code>.</li>
<li>Save the weights in a file and store it in <code>common/data/PMTs/measurement_matching_data/CE_weight/</code></li>
<li>Add to this file in the PMT data file under the key <code>jCEweightsFileName</code>.</li>
<li>Run the simulation again and check if the weights are correct.</li>
</ul>
<h2><a class="anchor" id="autotoc_md39"></a>
Step 4: Matching gain / transit time scans</h2>
<p>The scan data of transit time / gain must be corrected before use, as the coordinates of the beam do not necessarily correspond to the primary spot on the photocathode that is illuminated, since air-glass boundary refracts the beam.</p>
<ul>
<li>As before, we have to simulate the beam used during the scan measurement.</li>
<li>Change the profile vector and rLim in <code>runfrontalProfileScannNKT()</code> under <code>simulations/efficiency_calibration/OMSim_efficiency_calibration.cc</code></li>
<li>Run the XY grid simulation <b>using the simple PMT</b>, check the function being used under step 4</li>
</ul>
<div class="fragment"><div class="line">./OMSim_efficiency_calibration --simple_PMT --pmt_model 0 --simulation_step 4 -n 100000 --threads 4 --output_file step4 --detector_type 1</div>
</div><!-- fragment --><ul>
<li>Follow the analysis in the notebook <code>documentation/notebooks/scans_matching/</code> and save the created files in <code>common/data/PMTs/measurement_matching_data/scans/</code>. Note that <a class="el" href="class_o_m_sim.html" title="Controls the main simulation process.">OMSim</a> expects a naming convention for these files (see <code>OMSimPMTResponse::makeScansInterpolators</code>).</li>
<li>Add the vector with scanned wavelengths in PMT file with the key <code>jScannedWavelengths</code> and add the path with the newly created scan files under the key <code>jScanDataPath</code> (check <code>pmt_Hamamatsu_R15458_CAT.dat</code> for guidance).</li>
<li>Run the simulation in step 5 (modify method before accordingly) to check the output with the newly introduced files</li>
</ul>
<div class="fragment"><div class="line">./OMSim_efficiency_calibration --pmt_model 0 --simulation_step 5 -n 10000 --threads 4 --output_file step5 --detector_type 1</div>
</div><!-- fragment --><p>If you need to add more parameters (for example low gain probability, which is also photocathode position dependent and yet to be implemented), you will have to add a new interpolator map and <code>OMSimPMTResponse::makeScansInterpolators</code> accordingly.</p>
<hr  />
 <hr  />
 </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Jan 2 2025 20:49:37 for OMSim by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
